//! The game event manager handles events that are generated by SPECS systems.
//!
//! Sometimes, a SPEC system triggers some rare effect that it cannot handle
//! with the state that it usually requires. Always reading that other state
//! as well would cause too broad locking and often blows up parameters that
//! are being passed around.
//! As a solution, the system can send a message with the corresponding event
//! to the game event manager who always operates on the entire game state.
//!
//! Try to keep computations in here short and simple.

use crate::game::{
    components::*, player_info::PlayerInfo, story::StoryAction,
    units::attackers::change_duck_sprite_to_happy, units::attackers::Visitor,
};
use crate::gui::input::UiView;
use crate::gui::ui_state::Now;
use crate::init::quicksilver_integration::{GameState, Signal};
use crate::net::game_master_api::RestApiState;
use crate::prelude::*;
use paddlers_shared_lib::api::story::StoryStateTransition;
use paddlers_shared_lib::game_mechanics::town::*;
use paddlers_shared_lib::prelude::*;
use quicksilver::geom::Vector;
use specs::prelude::*;
use std::sync::mpsc::Sender;

/// The SPECS systems' endpoint
pub type EventPool = Sender<GameEvent>;

#[derive(Debug, PartialEq, Clone)]
/// This used to be just for `Game<'_,'_>` but now was moved up to `GameState`.
/// It is questionable if that makes sense. Ideally, this would be just `TownEvent`, staying in the scope of a single frame.
/// If anything should go between frames, than it should use the signal + notification publish-subscriber system that is to be created
/// (But how, frames in the same view need to communicate a lot)
pub enum GameEvent {
    HoboSatisfied(Entity),
    HttpBuyProphet,
    SendProphetAttack((i32, i32)),
    SwitchToView(UiView),
    StoryActions(Vec<StoryAction>),
}

impl GameState {
    pub fn handle_game_events(&mut self) {
        while let Ok(msg) = self.game.game_event_receiver.try_recv() {
            let result = self.try_handle_event(msg);
            self.game.check(result);
        }
    }
    fn try_handle_event(&mut self, evt: GameEvent) -> PadlResult<()> {
        match evt {
            GameEvent::HoboSatisfied(id) => {
                let mut rend_store = self.game.world.write_storage::<Renderable>();
                if let Some(mut rend) = rend_store.get_mut(id) {
                    change_duck_sprite_to_happy(&mut rend);
                }
                let hobo_store = self.game.world.read_storage::<Visitor>();
                if let Some(hobo) = hobo_store.get(id) {
                    if !hobo.hurried {
                        let mut v_store = self.game.world.write_storage::<Moving>();
                        if v_store.get(id).is_none() {
                            // hobo currently stopped (in frontend)
                            // => Set it moving again, assuming it has been released by the game-master
                            let ul = self.game.world.fetch::<ScreenResolution>().unit_length();
                            let now = self.game.world.fetch::<Now>().0;
                            let speed = hobo.speed;
                            let momentum = Vector::new(-speed, 0.0);
                            let pos =
                                Vector::new(TOWN_RESTING_X as f32 * ul, TOWN_LANE_Y as f32 * ul);
                            v_store.insert(id, Moving::new(now, pos, momentum, speed))?;
                        }
                        // Tell backend that release might be required
                        let net_store = self.game.world.read_storage::<NetObj>();
                        let net_id = net_store.get(id).ok_or(PadlError::dev_err(
                            PadlErrorCode::MissingComponent("NetObj"),
                        ))?;
                        RestApiState::get().http_notify_visitor_satisfied(HoboKey(net_id.id))?;
                    }
                }
            }
            GameEvent::HttpBuyProphet => {
                let player: PlayerInfo = *self.game.player().clone();
                crate::game::town::purchase_prophet(&player)?;
            }
            GameEvent::SendProphetAttack((x, y)) => {
                if self.game.town().idle_prophets.len() == 0 {
                    return PadlErrorCode::NotEnoughUnits.usr();
                }
                self.game.send_prophet_attack((x, y))?;
                // TODO: Only confirm if HTTP OK is returned
                // (Probably do this after cleaning pu network and promise handling)
                self.game
                    .confirm_to_user(format!("Attacking village <{}:{}>", x, y))?;
            }
            GameEvent::SwitchToView(view) => {
                self.game.switch_view(view);
            }
            GameEvent::StoryActions(actions) => {
                for a in actions {
                    self.try_handle_story_action(a)?;
                }
            }
        }
        Ok(())
    }
    fn try_handle_story_action(&mut self, action: StoryAction) -> PadlResult<()> {
        match action {
            StoryAction::OpenScene(scene, slide) => {
                self.viewer.global_event(
                    &mut self.game,
                    &PadlEvent::Signal(Signal::Scene(scene, slide)),
                )?;
                self.game.switch_view(UiView::Dialogue);
            }
            StoryAction::StoryProgress(new_state) => {
                let t = StoryStateTransition {
                    before: self.game.story_state(),
                    after: new_state,
                };
                RestApiState::get().http_update_story_state(t)?;
                self.viewer
                    .handle_signal(&mut self.game, Signal::NewStoryState(new_state))?;
            }
        }
        Ok(())
    }
}
