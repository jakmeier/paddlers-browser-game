//! The game event manager handles events that are generated by SPECS systems.

use crate::net::game_master_api::RestApiState;
use crate::net::{game_master_api::GameMasterResponse, request_foreign_town};
use crate::prelude::*;
use crate::{
    game::{
        components::*, player_info::PlayerInfo, units::attackers::Visitor, units::attackers::*,
    },
    net::game_master_api::HttpNotifyVisitorSatisfied,
};
use crate::{gui::ui_state::Now, net::state::current_village};
use crate::{gui::ui_state::UiState, net::game_master_api::GameMasterMessage};
use paddle::{Domain, NutsCheck};
use paddlers_shared_lib::prelude::*;
use paddlers_shared_lib::{
    api::{
        attacks::{InvitationDescriptor, StartFightRequest},
        hobo::SettleHobo,
        story::StoryStateTransition,
    },
    story::story_trigger::StoryTrigger,
};
use specs::prelude::*;

use super::{toplevel::Signal, town::nests::Nest};

pub struct EventManager;

/// Coordinates of a village in world map
pub type VillageCoordinate = (i32, i32);

/// Send a GameEvent to the game event manager (replaces endpoints that were copied everywhere before)
pub fn game_event(ev: GameEvent) {
    paddle::nuts::send_to::<EventManager, _>(ev);
}

#[derive(Debug, PartialEq, Clone)]
pub enum GameEvent {
    HoboSatisfied(Entity),
    #[allow(dead_code)]
    HttpBuyProphet,
    LoadHomeVillage,
    LoadVillage(VillageKey),
    SendProphetAttack(VillageCoordinate),
    /// Building entity of currently active town
    SendInvitation(Entity),
    DialogueActions(Vec<DialogueAction>),
    SwitchToView(UiView),
    DisplayConfirmation(TextKey),
    LetVisitorsIn(AttackKey),
    /// For objects that already exist in the frontend but are lacking the net id
    NetObjId(Entity, NetObj),
    SendGameMasterMessage(GameMasterMessage),
    GameMasterResponse(GameMasterResponse),
}

pub fn load_game_event_manager() {
    let event_manager_activity = nuts::new_domained_activity(EventManager, &Domain::Frame);
    event_manager_activity.private_domained_channel(|_, domain, event: GameEvent| {
        let game: &mut Game = domain.try_get_mut().expect("Forgot to insert game?");
        game.try_handle_event(event).nuts_check();
    });
}

impl Game {
    fn try_handle_event(&mut self, evt: GameEvent) -> PadlResult<()> {
        match evt {
            GameEvent::HoboSatisfied(id) => {
                let now = *self.world.fetch::<Now>();
                let town_world = self.town_world_mut();
                let mut rend_store = town_world.write_storage::<Renderable>();
                if let Some(mut rend) = rend_store.get_mut(id) {
                    change_duck_sprite_to_happy(&mut rend);
                }
                std::mem::drop(rend_store);
                let hobo_store = town_world.read_storage::<Visitor>();
                if let Some(hobo) = hobo_store.get(id) {
                    if !hobo.hurried {
                        let mut v_store = town_world.write_storage::<Moving>();
                        if v_store.get(id).is_none() {
                            // hobo currently stopped (in frontend)
                            // => Set it moving again, assuming it has been released by the game-master
                            let moving = release_and_move_visitor(hobo, now);
                            v_store.insert(id, moving)?;
                        }
                        // Tell backend that release might be required
                        let net_store = town_world.read_storage::<NetObj>();
                        let net_id = net_store.get(id).ok_or(PadlError::dev_err(
                            PadlErrorCode::MissingComponent("NetObj"),
                        ))?;
                        nuts::send_to::<RestApiState, _>(HttpNotifyVisitorSatisfied {
                            hobo: HoboKey(net_id.id),
                        });
                    }
                }
            }
            GameEvent::HttpBuyProphet => {
                let player: PlayerInfo = *self.player().clone();
                crate::game::town::purchase_prophet(&player)?;
            }
            GameEvent::SendProphetAttack((x, y)) => {
                self.send_prophet_attack((x, y))?;
                // TODO: Only confirm if HTTP OK is returned
                // (Probably do this after cleaning pu network and promise handling)
                self.confirm_to_user("attack-sent".into())?;
            }
            GameEvent::SwitchToView(view) => {
                self.switch_view(view);
            }
            GameEvent::DialogueActions(actions) => {
                for a in actions {
                    self.try_handle_story_action(a)?;
                }
            }
            GameEvent::LoadVillage(vid) => {
                self.town_context.load_foreign(vid);
                self.switch_view(UiView::Town);
                request_foreign_town(vid);
            }
            GameEvent::LoadHomeVillage => {
                self.town_context.reset_to_home();
            }
            GameEvent::DisplayConfirmation(t) => {
                self.confirm_to_user(t)?;
            }
            GameEvent::LetVisitorsIn(attack) => {
                let message = StartFightRequest {
                    destination: current_village(),
                    attack,
                };
                nuts::send_to::<RestApiState, _>(message);
                self.release_attack(attack);
                self.handle_story_trigger(StoryTrigger::LetVisitorIn);
            }
            GameEvent::NetObjId(entity, obj) => {
                self.town_world()
                    .write_component::<NetObj>()
                    .insert(entity, obj)?;
            }
            GameEvent::SendInvitation(foreign_entity) => {
                if !self.watergate_has_capacity() {
                    return PadlErrorCode::BuildingFull(Some(BuildingType::Watergate)).usr();
                }

                let world = self.town_world();
                let lazy = world.fetch();
                let mut nests = world.write_component::<Nest>();
                let netids = world.read_component::<NetObj>();

                let nest = nests
                    .get_mut(foreign_entity)
                    .expect("foreign nest vanished");
                nest.clear_hobos(&lazy)?;

                let netid = netids.get(foreign_entity).ok_or(PadlError::dev_err(
                    PadlErrorCode::MissingComponent("NetObj"),
                ))?;
                let msg = InvitationDescriptor {
                    nest: netid.as_building().expect("building"),
                    to: current_village(),
                };
                nuts::send_to::<RestApiState, _>(msg);

                crate::game::game_event_manager::game_event(GameEvent::DisplayConfirmation(
                    "invitation-sent".into(),
                ));
            }
            GameEvent::SendGameMasterMessage(msg_wrapper) => match msg_wrapper {
                GameMasterMessage::UpgradeBuilding(msg) => nuts::send_to::<RestApiState, _>(msg),
            },
            GameEvent::GameMasterResponse(response) => match response {
                GameMasterResponse::NewBuildingLevel(entity, level) => {
                    if let Some(building) = self
                        .home_town_world()
                        .write_component::<Building>()
                        .get_mut(entity)
                    {
                        building.level = level as u16;
                        paddle::share(Signal::BuildingUpgraded(building.bt));
                    }
                }
            },
        }
        Ok(())
    }
    fn try_handle_story_action(&mut self, action: DialogueAction) -> PadlResult<()> {
        match action {
            DialogueAction::OpenScene(scene, slide) => {
                paddle::share(crate::game::dialogue::LoadNewDialogueScene::new(
                    scene, slide,
                ));
                self.switch_view(UiView::Dialogue);
            }
            DialogueAction::StoryProgress(new_story_state, choice) => {
                let t = StoryStateTransition {
                    now: self.story_state(),
                    choice,
                };
                nuts::send_to::<RestApiState, _>(t);
                paddle::share(crate::game::dialogue::NewStoryState { new_story_state });
                if let Some(choice) = choice {
                    self.handle_story_trigger(StoryTrigger::DialogueChoice(choice));
                } else {
                    self.handle_story_trigger(StoryTrigger::DialogueStoryTrigger);
                }
            }
            DialogueAction::ClearSelectedUnit => {
                let world = self.town_context.world();
                world.write_resource::<UiState>().selected_entity = None;
            }
            DialogueAction::SettleHobo => {
                let e = self
                    .town_world()
                    .read_resource::<UiState>()
                    .selected_entity
                    .ok_or_else(|| {
                        PadlError::dev_err(PadlErrorCode::DevMsg("No entity selected"))
                    })?;

                let net_ids = self.town_world().read_component::<NetObj>();
                let nest_obj = net_ids
                    .get(e)
                    .ok_or_else(|| PadlError::dev_err(PadlErrorCode::MissingComponent("NetObj")))?;
                let nest = nest_obj.as_building().ok_or_else(|| {
                    PadlError::dev_err(PadlErrorCode::DevMsg("Expected nest to be selected"))
                })?;

                let rest_msg = SettleHobo { nest };
                nuts::send_to::<RestApiState, _>(rest_msg);
            }
        }
        Ok(())
    }
}
