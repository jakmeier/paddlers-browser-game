pub struct BuildingsQuery ; pub mod buildings_query { # ! [ allow ( dead_code ) ] pub const OPERATION_NAME : & 'static str = "BuildingsQuery" ; pub const QUERY : & 'static str = "query BuildingsQuery {\n  buildings {\n    id\n    x\n    y\n    buildingType\n    buildingRange\n    attackPower\n    attacksPerCycle\n  }\n}" ; use serde :: { Serialize , Deserialize } ; # [ allow ( dead_code ) ] type Boolean = bool ; # [ allow ( dead_code ) ] type Float = f64 ; # [ allow ( dead_code ) ] type Int = i64 ; # [ allow ( dead_code ) ] type ID = String ; # [ derive ( Eq , PartialEq ) ] pub enum BuildingType { BLUE_FLOWERS , RED_FLOWERS , Other ( String ) , } impl :: serde :: Serialize for BuildingType { fn serialize < S : serde :: Serializer > ( & self , ser : S ) -> Result < S :: Ok , S :: Error > { ser . serialize_str ( match * self { BuildingType :: BLUE_FLOWERS => "BLUE_FLOWERS" , BuildingType :: RED_FLOWERS => "RED_FLOWERS" , BuildingType :: Other ( ref s ) => & s , } ) } } impl < 'de > :: serde :: Deserialize < 'de > for BuildingType { fn deserialize < D : :: serde :: Deserializer < 'de >> ( deserializer : D ) -> Result < Self , D :: Error > { let s = < String > :: deserialize ( deserializer ) ? ; match s . as_str ( ) { "BLUE_FLOWERS" => Ok ( BuildingType :: BLUE_FLOWERS ) , "RED_FLOWERS" => Ok ( BuildingType :: RED_FLOWERS ) , _ => Ok ( BuildingType :: Other ( s ) ) , } } } # [ derive ( Deserialize ) ] pub struct BuildingsQueryBuildings { pub id : ID , pub x : Int , pub y : Int , # [ serde ( rename = "buildingType" ) ] pub building_type : BuildingType , # [ serde ( rename = "buildingRange" ) ] pub building_range : Option < Float > , # [ serde ( rename = "attackPower" ) ] pub attack_power : Option < Float > , # [ serde ( rename = "attacksPerCycle" ) ] pub attacks_per_cycle : Option < Int > , } # [ derive ( Serialize ) ] pub struct Variables ; # [ derive ( Deserialize ) ] pub struct ResponseData { # [ doc = "WIP for testing (should have at least a town filter)" ] pub buildings : Vec < BuildingsQueryBuildings > , } } impl graphql_client :: GraphQLQuery for BuildingsQuery { type Variables = buildings_query :: Variables ; type ResponseData = buildings_query :: ResponseData ; fn build_query ( variables : Self :: Variables ) -> :: graphql_client :: QueryBody < Self :: Variables > { graphql_client :: QueryBody { variables , query : buildings_query :: QUERY , operation_name : buildings_query :: OPERATION_NAME , } } }